<mxfile>
    <diagram id="ybN5I5CeERXQ-4qUqBBz" name="Page-1">
        <mxGraphModel dx="4435" dy="2798" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" background="#FFFFFF" math="0" shadow="0">
            <root>
                <mxCell id="0"/>
                <mxCell id="1" parent="0"/>
                <mxCell id="60" value="classDiagram&#10;class Application{&#10; %%GUI应用程序框架基类&#10; +init(...) bool&#10; +free()&#10; +run()&#10; +close()&#10; +draw_ui()&#10; +draw_gl()&#10; +framebuffer_size_callback(...)&#10;&#10; #GLFWwindow* window&#10;}&#10;&#10;class RobotBasicTools{&#10; %%机器基础工具应用程序&#10; +init(...) bool&#10; +free()&#10; +draw_ui()&#10; +draw_gl()&#10; +framebuffer_size_callback(...)&#10;&#10; -main_menu()&#10; -context_menu()&#10;&#10; -std::unique_ptr&lt;guik::GLCanvas&gt; main_canvas_ptr&#10; -std::unique_ptr&lt;guik::ProgressModal&gt; progress_ptr&#10; -std::shared_ptr&lt;dev::SensorManager&gt; sensor_manager_ptr&#10; -std::shared_ptr&lt;dev::AprilBoard&gt; april_board_ptr&#10; -std::unique_ptr&lt;calibration::CamLaserCalib&gt; cl_calib_ptr&#10;}&#10;&#10;class GLCanvas{&#10; %%处理openGL中相机模型，投影方式以及渲染显示&#10; +ready() bool&#10; +reset_camera()&#10; +set_size(...)&#10; +mouse_control()&#10; +bind(clear_buffers)&#10; +unbind()&#10; +render_to_screen(color_buffer_id)&#10; +pick_info(...) Vector4i&#10; +pick_depth(...) float&#10; +unproject(...) Vector3f&#10; +show_shader_setting()&#10; +draw_ui()&#10; +show_projection_setting()&#10;&#10; +std::unique_ptr&lt;glk::GLSLShader&gt; shader&#10; +std::unique_ptr&lt;glk::FrameBuffer&gt; frame_buffer&#10; +std::unique_ptr&lt;glk::TextureRenderer&gt; texture_renderer&#10; +std::unique_ptr&lt;guik::CameraControl&gt; camera_control&#10; +std::unique_ptr&lt;guik::ProjectionControl&gt; projection_control&#10;}&#10;&#10;class Singleton{&#10; %%单实例模板类&#10; &lt;&lt;template&gt;&gt;&#10;}&#10;&#10;SensorManager &lt;--o Singleton&#10;&#10;Application &lt;|-- RobotBasicTools : I&#10;GLCanvas &lt;--o RobotBasicTools : D&#10;ProgressModal &lt;--o RobotBasicTools : D&#10;Singleton &lt;--o RobotBasicTools : D&#10;AprilBoard &lt;--o RobotBasicTools : D&#10;CamLaserCalib &lt;--o RobotBasicTools : D&#10;&#10;GLSLShader &lt;--o GLCanvas : D&#10;TextureRenderer &lt;--o GLCanvas : D&#10;FrameBuffer &lt;--o GLCanvas : D&#10;ProjectionControl &lt;--o GLCanvas : D&#10;CameraControl &lt;--o GLCanvas : D&#10;&#10;class GLSLShader{&#10; %%openGL染色器控制操作&#10; +init() bool&#10; +use()&#10; +attrib(name) GLint&#10; +uniform(name) GLint&#10; +get_uniform4f(name) Vector4f&#10; +get_uniform_matrix4f(name) Matrix4f&#10; +set_uniform(name, value)&#10;&#10; -read_shader_from_file(filename, shader_type)&#10;&#10; -GLuint shader_program&#10; -std::unordered_map&lt;std::string, GLint&gt; attrib_cache&#10; -std::unordered_map&lt;std::string, GLint&gt; uniform_cache&#10;}&#10;&#10;class FrameBuffer{&#10; %%openGL帧缓存封装&#10; +bind()&#10; +unbind()&#10; +add_color_buffer(...)&#10; +color() Texture&#10; +depth() Texture&#10;&#10; -int width&#10; -int height&#10; -GLint viewport[4]&#10; -GLuint frame_buffer&#10; -std::vector&lt;std::shared_ptr&#10; &lt;Texture&gt;&gt; color_buffers&#10; -std::shared_ptr&lt;Texture&gt; depth_buffer&#10;}&#10;&#10;class Texture{&#10; %%openGL纹理封装&#10; +id() GLuint&#10; +size() Vector2i&#10; +T_read_pixels() std_vector_T&#10;}&#10;&#10;Texture &quot;*&quot; &lt;--o &quot;1&quot; FrameBuffer : D&#10;&#10;class TextureRenderer{&#10; %%openGL帧缓存显示控制&#10; +draw(texture)&#10; &#10; -GLSLShader shader&#10;}&#10;&#10;GLSLShader &lt;--* TextureRenderer : C&#10;&#10;class CameraControl{&#10; %%openGL相机控制基类&#10; +mouse(...)&#10; +drag(...)&#10; +scroll(rel)&#10; +view_matrix() Matrix4f&#10;}&#10;&#10;class ArcCameraControl{&#10; %%极坐标arctic相机控制模型&#10; +mouse(...)&#10; +drag(...)&#10; +scroll(rel)&#10; +view_matrix() Matrix4f&#10; &#10; -Vector3f center&#10; -double distance&#10; -...&#10;}&#10;&#10;CameraControl &lt;|-- ArcCameraControl : I&#10;&#10;class ProjectionControl{&#10; %%openGL投影控制&#10; +set_size(size)&#10; +projection_matrix() Matrix4f&#10; +draw_ui()&#10; +show()&#10;&#10; -int projection_mode&#10; -Vector2i size&#10; -bool show_window&#10; -float fovy&#10; -float width&#10; -float near&#10; -float far&#10;}&#10;&#10;class Drawable{&#10; %%openGL绘图对象抽象类&#10; +free()&#10; +draw(shader)&#10;}&#10;&#10;class Lines{&#10; %%openGL直线对象&#10; +draw(shader)&#10;}&#10;&#10;class Mesh{&#10; %%openGL mesh对象&#10; +free()&#10; +draw(shader)&#10;}&#10;&#10;class PointCloudBuffer{&#10; %%openGL点云对象&#10; +free()&#10; +draw(shader)&#10;}&#10;&#10;class SimpleLines{&#10; %%openGL简单直线对象&#10; +draw(shader)&#10;}&#10;&#10;Drawable &lt;|-- Lines : I&#10;Drawable &lt;|-- Mesh : I&#10;Drawable &lt;|-- PointCloudBuffer : I&#10;Drawable &lt;|-- SimpleLines : I&#10;&#10;class Primitives{&#10; %%openGL图元工厂类&#10; +instance()* Primitives_ptr&#10; +primitive(type) Drawable&#10;&#10; -Primitives *instance_&#10; -std::vector&lt;std::shared_ptr&lt;&#10; glk::Drawable&gt;&gt; meshes&#10;}&#10;&#10;class Icosahedron{&#10; %%二十面体&#10;}&#10;&#10;class Cube{&#10; %%立方体&#10;}&#10;&#10;class Cone{&#10; %%椎体&#10;}&#10;&#10;class Grid{&#10; %%栅格&#10;}&#10;&#10;class CoordinateSystem{&#10; %%坐标系&#10;}&#10;&#10;Icosahedron &lt;-- Primitives : A&#10;Cone &lt;-- Primitives : A&#10;Cube &lt;-- Primitives : A&#10;Grid &lt;-- Primitives : A&#10;CoordinateSystem &lt;-- Primitives : A&#10;Lines &quot;*&quot; &lt;--o &quot;1&quot; Primitives : D&#10;Mesh &quot;*&quot; &lt;--o &quot;1&quot; Primitives : D&#10;&#10;Primitives &lt;-- RobotBasicTools : A&#10;&#10;class ProgressInterface{&#10; %%GUI进度条接口&#10; &lt;&lt;interface&gt;&gt;&#10; +set_title(title)&#10; +set_text(text)&#10; +set_maximum(max)&#10; +set_current(current)&#10; +increment()&#10;}&#10;&#10;class ProgressModal{&#10; %%GUI进度条模块&#10; +set_title(title)&#10; +set_text(text)&#10; +set_maximum(max)&#10; +set_current(current)&#10; +increment()&#10; +T_open(...)&#10; +T_result() T&#10; +run(task_name) bool&#10;&#10; -thread thread_&#10; -boost_any result_&#10; -atomic_bool running_&#10; -atomic_int max_&#10; -atomic_int current_&#10; -...&#10;}&#10;&#10;ProgressInterface &lt;|-- ProgressModal : I&#10;&#10;class Sensor{&#10; %%传感器抽象类&#10; +free()&#10; +change_sensor_name(name)&#10; +is_sensor_online() bool&#10; +draw_status()&#10; +show()&#10; +load_model()&#10; +free_model()&#10; +marked_to_be_deleted()&#10; +is_to_be_deleted() bool&#10; +draw_gl(shader)&#10; +draw_ui()&#10;&#10; +string sensor_name&#10; +uint32_t sensor_id&#10; +...&#10;&#10; #std::unique_ptr&lt;glk::Drawable&gt; ply_model_ptr_&#10; #...&#10;}&#10;&#10;class SensorManager{&#10; %%传感器管理器&#10; +add_sensor(sensor)&#10; +draw_gl(shader)&#10; +draw_ui()&#10; +free()&#10;&#10; +std::unordered_map&lt;dev::SENSOR_TYPE, &#10; std::list&lt;dev::Sensor::Ptr&gt;&gt; sensors_map&#10;&#10; -check_and_clear_sensors()&#10; -call_sensors_draw_ui()&#10;}&#10;&#10;Drawable &lt;--o Sensor : D&#10;Sensor &lt;--o SensorManager : D&#10;&#10;class SensorData{&#10; %%传感器数据抽象类&#10; &lt;&lt;template&gt;&gt;&#10; +subscribe(topic, queue_size)&#10; +unsubscribe()&#10; +set_msgs_deque_size(cache_size)&#10; +set_data_rate(data_rate)&#10;&#10; -callback(msg)&#10;&#10; -boost::shared_ptr&lt;&#10; message_filters::Subscriber&lt;M&gt;&gt; sub_&#10; -std::deque&lt;MConstPtr&gt; msgs_&#10; -...&#10;}&#10;&#10;class Laser{&#10; %%激光传感器封装&#10; +free()&#10; +draw_gl(shader)&#10; +draw_ui()&#10;&#10; -check_online_status()&#10; -...()&#10;&#10; -bool b_show_laser_&#10; -std::shared_ptr&lt;SensorData&lt;&#10; sensor_msgs::LaserScan&gt;&gt; laser_raw_data_ptr_&#10; -std::shared_ptr&lt;&#10; glk::PointCloudBuffer&gt; pointcloud_buffer_ptr_&#10;}&#10;&#10;class Camera{&#10; %%相机传感器封装&#10; +free()&#10; +draw_gl(shader)&#10; +draw_ui()&#10; +data()&#10; +cam() camera_model_Camera&#10; -creat_instance(current_camera_type)&#10; -...()&#10;&#10; -boost::shared_ptr&lt;&#10; camera_model::Camera&gt; inst_ptr_&#10; -std::shared_ptr&lt;SensorData&lt;&#10; sensor_msgs::Image&gt;&gt; image_data_ptr_&#10; -std::shared_ptr&lt;SensorData&lt;&#10; sensor_msgs::PointCloud2&gt;&gt; points_data_ptr_&#10; -std::shared_ptr&lt;dev::ImageShow&gt; im_show_ptr_&#10; -...&#10;&#10;}&#10;&#10;class ImageShow{&#10; %%图像显示封装&#10; +update_image(image)&#10; +enable(window_name, is_use_opencv)&#10; +disable()&#10; +show_image(is_show_image)&#10;&#10; -show_in_opencv()&#10; -update_texture()&#10;&#10;}&#10;&#10;PointCloudBuffer &lt;--o Laser : D&#10;SensorData &lt;--o Laser : D&#10;SensorData &lt;--o Camera : D&#10;Sensor &lt;|-- Laser : I&#10;Sensor &lt;|-- Camera : I&#10;ImageShow &lt;--o Camera : D&#10;&#10;class AprilBoard{&#10; %%标定板封装&#10; +draw_ui()&#10; +show()&#10; +boost::shared_ptr&lt;aslam::&#10; cameras::GridCalibrationTargetAprilgrid&gt; board&#10;}&#10;&#10;class Task{&#10; %%标定流程后台任务抽象类&#10; +T_do_task(task_name, task, args) bool&#10; +T_create(task_name, task, args)&#10; +T_result() T&#10; +is_terminated(task_name) bool&#10;&#10; -string task_name_&#10; -atomic_bool is_running_&#10; -thread thread_&#10; -boost_any result_&#10;}&#10;&#10;class BaseCalib{&#10; %%标定基础类&#10; +show()&#10; +T_draw_sensor_selector(name, type, sensor)&#10; +draw_gl(shader)&#10; +draw_ui()&#10;&#10; #std::shared_ptr&lt;&#10; dev::SensorManager&gt; sensor_manager_ptr_&#10; #...&#10;}&#10;&#10;SensorManager &lt;--o BaseCalib : D&#10;&#10;class CamLaserCalib{&#10; %%相机与单线激光标定类 &#10; +draw_gl(shader)&#10; +draw_ui()&#10;&#10; -update_data()&#10; -get_pose_and_points()&#10; -calibration()&#10; -check_and_save()&#10; -calc()&#10; -load_calib_data(file_path)&#10; -save_calib_data(file_path)&#10;&#10; -std::shared_ptr&lt;&#10; dev::AprilBoard&gt; april_board_ptr_&#10; -std::shared_ptr&lt;dev::Camera&gt; cam_dev_ptr_&#10; -std::shared_ptr&lt;dev::Laser&gt; laser_dev_ptr_&#10; -std::shared_ptr&lt;&#10; dev::ImageShow&gt; image_imshow_ptr_&#10; -std::shared_ptr&lt;&#10; dev::ImageShow&gt; laser_imshow_ptr_&#10; -std::shared_ptr&lt;Task&gt; task_ptr_&#10; -...&#10;}&#10;&#10;&#10;AprilBoard &lt;--o CamLaserCalib : D&#10;Camera &lt;--o CamLaserCalib : D&#10;Laser &lt;--o CamLaserCalib : D&#10;ImageShow &quot;2&quot; &lt;--o CamLaserCalib : D&#10;Task &lt;--o CamLaserCalib : D&#10;BaseCalib &lt;|-- CamLaserCalib : I&#10;&#10;class TwoLasersCalib{&#10; %%两个单线激光标定&#10; +draw_gl(shader)&#10; +draw_ui()&#10;&#10; -update()&#10; -calibration()&#10; -get_valid_lines()&#10;&#10; -std::array&lt;LaserInstType, 2&gt; laser_insts_&#10; -std::shared_ptr&lt;Task&gt; task_ptr_&#10; -...&#10;}&#10;&#10;&#10;Laser &quot;2&quot; &lt;--o TwoLasersCalib : D&#10;Task &lt;--o TwoLasersCalib : D&#10;BaseCalib &lt;|-- TwoLasersCalib : I&#10;ImageShow &quot;2&quot; &lt;--o TwoLasersCalib : D&#10;SimpleLines &quot;2&quot; &lt;--o TwoLasersCalib : D" style="shadow=0;dashed=0;align=left;strokeWidth=1;shape=mxgraph.mermaid.abstract.mermaid;labelBackgroundColor=#ffffff;noLabel=1;fillColor=#008a00;strokeColor=#005700;fontColor=#ffffff;" parent="1" vertex="1">
                    <mxGeometry x="-1320" y="-970" width="4870" height="1770" as="geometry"/>
                </mxCell>
            </root>
        </mxGraphModel>
    </diagram>
</mxfile>